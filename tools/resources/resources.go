// Package resources provides unfancy resources embedding with Go.
package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// File mimicks the os.File and http.File interface.
type File interface {
	io.Reader
	Stat() (os.FileInfo, error)
}

// New creates a new Package.
func New() *Package {
	return &Package{
		Config: Config{
			Pkg: "resources",
			Var: "FS",
		},
		Files: make(map[string]File),
	}
}

// Config defines some details about the output file.
type Config struct {
	Pkg string // Pkg holds the package name
	Var string // Var holds the variable name for the virtual filesystem
	Tag string // Tag may hold an optional build tag, unless empty
}

// A Package describes a collection of files and how they should be transformed
// to an output.
type Package struct {
	Config
	Files map[string]File
}

// Add a file to the package at the give path.
func (p *Package) Add(name string, file File) error {
	name = filepath.ToSlash(name)
	p.Files[name] = file

	return nil
}

// AddFile is a helper function that adds the files from the path into the
// package under the path file.
func (p *Package) AddFile(name, path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}

	return p.Add(name, f)
}

// Build compiles the package and writes it into an io.Writer.
func (p *Package) Build(out io.Writer) error {
	return pkg.Execute(out, p)
}

// Write builds the package (via Build) and writes the output the file
// given by the path argument.
func (p *Package) Write(path string) error {
	err := os.MkdirAll(filepath.Dir(path), 0700)
	if err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}

	defer func() {
		err := f.Close()
		if err != nil {
			log.Panicf("Failed to close file: %s", err)
		}
	}()

	return p.Build(f)
}

var (
	// Template.
	pkg *template.Template

	// BlockWidth allows to adjust the number of bytes per line in the generated file.
	BlockWidth = 12
)

func reader(input io.Reader, indent int) (string, error) {
	var (
		buff      bytes.Buffer
		strbuf    strings.Builder
		isString  bool
		err       error
		curblock  = 0
		linebreak = "\n" + strings.Repeat("\t", indent)
	)

	b := make([]byte, BlockWidth)
	isString = true

	for n, e := input.Read(b); e == nil; n, e = input.Read(b) {
		for i := range n {
			if isString {
				if isGoASCII(rune(b[i])) {
					strbuf.WriteByte(b[i])
				} else {
					isString = false
				}
			}

			_, e = fmt.Fprintf(&buff, "0x%02x,", b[i])
			if e != nil {
				err = e

				break
			}

			curblock++
			if curblock < BlockWidth {
				buff.WriteRune(' ')

				continue
			}

			buff.WriteString(linebreak)

			curblock = 0
		}
	}

	if isString {
		return "[]byte(`" + strbuf.String() + "`),", err
	}

	return "{" + linebreak + buff.String() + "\n" + strings.Repeat("\t", indent-1) + "},", err
}

func isGoASCII(b rune) bool {
	if ((' ' <= b && b <= '~') || b == '\n' || b == '\t' || b == '\r') && b != '`' {
		return true
	}

	return false
}

func init() {
	pkg = template.Must(template.New("file").Funcs(template.FuncMap{"reader": reader}).Parse(fileTemplate))
	pkg = template.Must(pkg.New("pkg").Parse(pkgTemplate))
}

const fileTemplate = `{{ reader . 4 }}`

const pkgTemplate = `// Code generated by github.com/forensicanalysis/go-resources. DO NOT EDIT.

{{ if .Tag }}// +build {{ .Tag }}

{{ end }}
package {{ .Pkg }}

var {{ .Var }} = map[string][]byte{ {{range $path, $file := .Files }}
	"/{{ $path }}": {{ template "file" $file }}{{ end }}
}
`
